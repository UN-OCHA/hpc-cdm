
import {catchError, map} from 'rxjs/operators';
import { Injectable } from '@angular/core';
import { HttpClient, HttpResponse, HttpParams, HttpHeaders } from '@angular/common/http';
// import { FormGroup, FormControl } from '@angular/forms';
//
import * as _ from 'lodash';
import { Observable } from 'rxjs/Rx';

import { QuestionBase } from '../models/question-base';
import { TextboxQuestion, TextareaQuestion, CheckboxQuestion, DropdownQuestion } from '../models';

import { ApiService } from 'app/shared/services/api/api.service'

import { environment } from 'environments/environment';

@Injectable()
export class QuestionService {

  private objectTypes = {
    'planProcedure': {
      'root': 'v2/planProcedure',
      'fields': {
        'id': {
          'required': true,
          'type': 'number'
        },
        'planId': {
          'required': true,
          'type': 'number'
        },
        'createdAt': {
          'required': true,
          'type': 'textbox',
          'metaType': 'date',
          'notEditable': true
        },
        'updatedAt': {
          'required': true,
          'type': 'textbox',
          'metaType': 'date',
          'notEditable': true
        },
        'conditionFields': {
          'required': true,
          'parentKey': 'planId',
          'foreignKey': 'conditionField',
          'autoGenerated': true // These are automatically created on the back-end.
        },

        'procedureEntityPrototypes': {
          'required': true,
          'parentKey': 'planId',
          'foreignKey': 'procedureEntityPrototype',
          'autoGenerated': true // These are automatically created on the back-end.
        },
        'workflowStatusOptions': {
          'required': true,
          'parentKey': 'planId',
          'foreignKey': 'workflowStatusOption',
          'autoGenerated': true // These are automatically created on the back-end.
        },
        'procedureSections': {
          'required': true,
          'parentKey': 'planId',
          'foreignKey': 'procedureSection',
          'autoGenerated': true // These are automatically created on the back-end.
        }
      },
    },
    'procedureSection': {
      'root': 'v2/procedureSection',
      'fields': {
        'id': {
          'required': true,
          'type': 'number'
        },
        'planId': {
          'required': true,
          'isParentKey': true,
          'type': 'number'
        },
        'order': {
          'type': 'number'
        },
        'createdAt': {
          'required': true,
          'type': 'textbox',
          'metaType': 'date',
          'notEditable': true
        },
        'updatedAt': {
          'required': true,
          'type': 'textbox',
          'metaType': 'date',
          'notEditable': true
        },
        'name': {
          'maxlength': 64
        },
        'conditionFields': {
          'isJSON': true,
          'transform': (objects) => {
            return _.map(objects, (object) => {
              if (typeof object === 'number') {
                return object;
              } else if (object['id']) {
                return object['id'];
              } else {
                return object['conditionFieldId'];
              }
            })
          }
        }
      },
    },
    'conditionField': {
      'root': 'v2/conditionField',
      'fields': {
        'id': {
          'required': true,
          'type': 'number'
        },
        'planId': {
          'isParentKey': true,
          'required': true,
          'type': 'number'
        },
        'name': {
          'maxlength': 64
        },
        'fieldType': {
          'controlType': 'select',
          'required': true,
          'options': [{
            'key': 'select',
            'value': 'select'
          }, {
            'key': 'text',
            'value': 'text'
          }, {
            'key': 'textarea',
            'value': 'textarea'
          }, {
            'key': 'checkbox',
            'value': 'checkbox'
          }, {
            'key': 'number',
            'value': 'number'
          }]
        },
        'order': {
          'type': 'number'
        },
        'description': {
          'controlType': 'textarea'
        },
        'createdAt': {
          'required': true,
          'type': 'textbox',
          'metaType': 'date',
          'notVisible': true
        },
        'updatedAt': {
          'required': true,
          'type': 'textbox',
          'metaType': 'date',
          'notVisible': true
        },
       'rules': {
          'controlType': 'textarea',
          'isJSON': true,
          'example': `
This is dependent on the \`fieldType\`
*e.g.*
\`\`\`
{
  "options": [
    "Cluster",
    "Refugee"
  ],
  // or
  "max": 0,
  "min": 10,
  "conditionality": {"value": <true|"a string">}
}
\`\`\`
Type \`null\` or \`{}\` if there are no rules, otherwise
          `
        },
        'isReliedOnBy': {
          'isJSON': true,
          'transform': (objects) => {
            return _.map(objects, object => object['id'])
          }
        },
        'label': {
          'controlType': 'textarea',
          'isJSON': true,
          'required': true
        },
        'required': {
          'type': 'boolean',
          'controlType': 'checkbox'
        },
        'grouping': {
          'type': 'boolean',
          'controlType': 'checkbox'
        },
      },
    },
    'workflowStatusOption': {
      'root': 'v2/workflowStatusOption',
      'fields': {
        'id': {
          'required': true,
          'type': 'number'
        },
        'planId': {
          'required': true,
          'type': 'number'
        },
        'type': {
          required: true
        },
        'value': {
          'controlType': 'textarea',
          'isJSON': true,
          'example': `
*e.g.*
\`\`\`
{
  "label": {
    "en": "label for step"
  }
}
\`\`\`
Type \`null\` or \`{}\` if there are no labels, otherwise
`

        },
        'previousSteps': {
          'isJSON': true,
          'transform': (objects) => {
            return _.map(objects, object => _.pick(object, ['id', 'fromId', 'toId', 'value']))
          }
        },
        'nextSteps': {
          'isJSON': true,
          'transform': (objects) => {
            return _.map(objects, object => _.pick(object, ['id', 'fromId', 'toId', 'value']))
          }
        },
        'createdAt': {
          'required': true,
          'type': 'textbox',
          'metaType': 'date',
          'notVisible': true
        },
        'updatedAt': {
          'required': true,
          'type': 'textbox',
          'metaType': 'date',
          'notVisible': true
        },

      },
    },
    'procedureEntityPrototype': {
      'root': 'v2/procedureEntityPrototype',
      'fields': {
        'id': {
          'required': true,
          'type': 'number'
        },
        'planId': {
          'required': true,
          'type': 'number'
        },
        'entityPrototypeId': {
          'required': true,
          'type': 'number',
        },
        'createdAt': {
          'required': true,
          'type': 'textbox',
          'metaType': 'date',
          'notVisible': true
        },
        'updatedAt': {
          'required': true,
          'type': 'textbox',
          'metaType': 'date',
          'notVisible': true
        },

      },
    }
  };

  private baseUrl = environment.serviceBaseUrl;

  constructor (
    private http: HttpClient,
    private apiService: ApiService
  ) {}

  public getObjectList (objectType: string, options?: any) {

    const url = this.buildUrl(this.objectTypes[objectType].root);

    const params: HttpParams = this.apiService.setParams(options);
    const headers: HttpHeaders = this.apiService.setHeaders();

    return this.http.get(url, {params, headers}).pipe(
      map((res: HttpResponse<any>) => this.unwrap(res)),
      catchError(this.apiService.processError.bind(this.apiService)));
  }

  public getObjectById (objectType: string, id: number, options?: any) {

    const url = this.buildUrl(this.objectTypes[objectType].root + '/' + id);

    const params: HttpParams = this.apiService.setParams(options);
    const headers: HttpHeaders = this.apiService.setHeaders();

    return this.http.get(url, {params, headers}).pipe(
      map((res: HttpResponse<any>) => this.unwrap(res)),
      map((data: any) => this.transformAPIObjectIntoQuestion(objectType, data)),
      catchError(this.apiService.processError.bind(this.apiService)));
  }

  public updateObject (objectType: string, id: number, options): Observable<any> {
    const url = this.buildUrl(this.objectTypes[objectType].root + '/' + id);
    // we want to remove the options id
    delete options.id;

    // clean up the data.
    options = this.prepareForAPI(options, objectType);

    const params: HttpParams = this.apiService.setParams(options);
    const headers: HttpHeaders = this.apiService.setHeaders();

    return this.http.put(url, {data: options}, {params, headers}).pipe(
      map((res: HttpResponse<any>) => this.unwrap(res)),
      map((data: any) => { return data; }),
      catchError(() => this.apiService.processError.bind(this.apiService)));
  }

  public createObject (objectType, options) {
    const url = this.buildUrl(this.objectTypes[objectType].root);

    options = this.prepareForAPI(options, objectType);

    const params: HttpParams = this.apiService.setParams(options);
    const headers: HttpHeaders = this.apiService.setHeaders();

    return this.http.post(url, {data: options}, {params, headers}).pipe(
      map((res: HttpResponse<any>) => this.unwrap(res)),
      map((data: any) => { return data; }),
      catchError(this.apiService.processError.bind(this.apiService)));
  }

  public deleteObjectById (objectType: string, id: number) {
    const url = this.buildUrl(this.objectTypes[objectType].root + '/' + id);

    const params: HttpParams = this.apiService.setParams();
    const headers: HttpHeaders = this.apiService.setHeaders();

    return this.http.delete(url, {params, headers}).pipe(
        catchError(this.apiService.processError.bind(this.apiService)));
  }

  private prepareForAPI (options, objectType) {
    Object.keys(options).forEach(key => {
      const metaType = this.objectTypes[objectType].fields[key].metaType;
      const originalType = this.objectTypes[objectType].fields[key].type;
      const isJSON = this.objectTypes[objectType].fields[key].isJSON;
      const isForeign = !!this.objectTypes[objectType].fields[key].foreignKey;

      if ((originalType === 'date' || originalType === 'number' || metaType === 'date') &&
          options[key] === '') {
        options[key] = null;
      } else if (originalType === 'boolean') {
        options[key] = !!options[key];
      }

      if ((isJSON || isForeign) && typeof options[key] === 'string') {
        options[key] = JSON.parse(options[key]);
      }
    });

    return options;
  }

  private unwrap (res: HttpResponse<any>) {
    return res['data'];
  }

  // Transforms the passed object into a series of
  // questions based
  public transformAPIObjectIntoQuestion (objectType, object, isNew?): QuestionBase<any>[] {
    const questions: QuestionBase<any>[] = []

    const prototype = this.objectTypes[objectType];
    // loop through all the fields
    Object.keys(prototype.fields).forEach((field, index) => {
      const fieldPrototype = prototype.fields[field];
      // for some fields we don't add values when we're creating a new object,
      // additionally, if the field is autogenerated on the back-end
      // we don't want to include those fields in the form.
      if (isNew &&
          (['createdAt', 'updatedAt', 'id'].indexOf(field) !== -1 ||
           fieldPrototype.autoGenerated)) {
        return;
      }

      if (!Array.isArray(object[field])) {
        this.handleSimpleQuestions(questions, object, field, index, fieldPrototype);
      } else if (!fieldPrototype.foreignKey) {
        // if there's no foreignKey associated with it
        // we just edit it as json.
        fieldPrototype.isJSON = true;
        fieldPrototype.controlType = 'textarea';

        this.handleSimpleQuestions(questions, object, field, index, fieldPrototype);
      } else {
        // else it's an array and we want to create
        // an object to contain the nested questions
        // for the relationship.
        const relationships = [];

        // We sort before we get going.
        object[field] = object[field].sort((a, b) => {
          if (a.order !== undefined || b.order !== undefined) {
            return a.order - b.order;
          } else {
            return a.id - b.id;
          }
        });

        object[field].forEach(nestedObject => {
          const relationshipQuestions = this.transformAPIObjectIntoQuestion(fieldPrototype.foreignKey, nestedObject);

          relationships.push({
            id: nestedObject.id,
            parentKey: fieldPrototype.parentKey,
            nestedQuestions: relationshipQuestions,
            objectType: fieldPrototype.foreignKey
          });
        });

        questions.push(new QuestionBase({
          value: relationships,
          label: field,
          key: fieldPrototype.foreignKey,
          controlType: 'related'
        }));
      }
    });

    return questions.sort((a, b) => a.order - b.order);
  }

  private handleSimpleQuestions (
    questions: QuestionBase<any>[],
    object: any, // The original object.
    field: string, // the name of the field
    index: number,
    fieldPrototype: any,
  ) {

    let value = object[field];

    if (fieldPrototype.isParentKey && object.parentObjectId) {
      value = object.parentObjectId;
    }

    if (fieldPrototype.transform && typeof fieldPrototype.transform === 'function') {
      value = fieldPrototype.transform(value);
    }

    const newQuestion = {
      key: field,
      maxlength: fieldPrototype.maxlength,
      label: field,
      value: value,
      required: fieldPrototype.required,
      order: index,
      example: fieldPrototype.example,
      disabled: fieldPrototype.notEditable || fieldPrototype.isParentKey,
      notVisible: fieldPrototype.notVisible
    };

    switch (fieldPrototype.controlType) {
      case 'textarea':
        newQuestion['isJSON'] = fieldPrototype.isJSON;
        questions.push(new TextareaQuestion(newQuestion));
        break;
      case 'checkbox':
        questions.push(new CheckboxQuestion(newQuestion));
        break;
      case 'select':
        newQuestion['options'] = fieldPrototype.options;
        questions.push(new DropdownQuestion(newQuestion));
        break;
      default:
        newQuestion['type'] = fieldPrototype.type;
        questions.push(new TextboxQuestion(newQuestion));
    }
  }

  private buildUrl(endpoint: string): string {
    return this.baseUrl + endpoint;
  }
}
